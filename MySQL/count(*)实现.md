不同的MySQL引擎中，实现方式不同。
	• MyISAM将一个表的总行数存在了磁盘，因此执行count(*)时会直接返回这个数，效率很高；
	• InnoDB，执行count(*)，需要把数据一行一行地从引擎里面读出来，累计计数；

InnoDB不跟MyISAM一样，把总数存起来的原因
由于多版本并发控制(MVCC)的原因，即使同一时刻的多个查询，InnoDB应该返回多少行也不确定。
可重复读是InnoDB默认隔离级别，每一行记录都要判断自己是否对这个会话可见。
MySQL优化器会找到最小的索引树来遍历。
在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。
show table status 命令显示的行数不能直接使用，误差达到40%到50%。

解决方案：将总数记录在数据库中单独的一张计数表中，InnoDB支持崩溃恢复不丢数据。

count()是一个聚合函数，如果count函数的参数不是NULL，累计值加1，否则不加。

Server层要什么给什么，InnoDB只给必要的值；

按照效率排序，count(字段)<count(主键id)<count(1)≈count(*)

MySQL与Redis，两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。
