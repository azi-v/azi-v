根据加锁范围，MySQL的锁可以分为全局锁、表锁和行锁三类；

全局锁
对整个数据库实例加锁，flush tables with lock；可以使整个库处于只读状态，之后其他线程的以下语句会被阻塞：数据的增删改、数据定义语句、更新类事务的提交语句。

全局锁的使用场景，做全库逻辑备份，即将整个表都select出来存成文本。
备份过程中整个库完全处于只读状态。
	• 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
	• 如果在从库上备份，备份期间从库不能执行主库同步过来的binlog，会导致主从延迟；
备份为什么需要加锁：不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。官方自带的逻辑备份工具是mysqldump，当mysqldump使用参数-single-transaction的时候，导数据之前会启动一个事务，来确保拿到一致性视图，由于MVCC的支持。这个过程中数据是可以正常更新的。

一致性读的前提是引擎支持这个隔离级别，single-stransaction方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过FLWRL方法。

使用FTWRL方式而不是用set global readonly=true的原因：
	• 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此修改global变量的方式影响面更大；
	• 异常处理机制上有差异。如果FTWRL后，客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态；readonly会一直保持readonly状态，这样会导致整个库长时间处于不可写状态。
业务的更新不只是增删改查(DML)，还有可能是加字段等修改表结构的操作(DDL)。


表级锁
表级锁有两种：一种是表锁，一种是元数据锁

表锁语法 lock tables … read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可在客户端断开时自动释放；
Lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

元数据锁meta data lock。不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是保证读写的正确性。MySQL5.5引入MDL，当对一个表做增删改查操作时，加MDL读锁；当要对表做结构变更时，加MDL写锁。
	• 读锁之间不互斥，因此可以多个线程同时对一张表增删改查；
	• 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

MDL锁是系统默认会加的，但是不能忽略；给表加一个字段，导致整个库挂了；
给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据
表上的查询语句频繁，而且客户端有重试机制，也就是超时后会再起一个新session在请求的话，这个库的线程很快就会爆满。

事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后释放。

如何安全地给小表加字段？
首先要解决长事务，事务不提交，就会一直占着MDL锁。
在MySQL的information_schema库的innodb_trx表中，可以查到当前执行的事务。如果要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。
设定等待时间


表锁一般是在数据库引擎不支持行锁的时候才会被用到。如果你发现你的应用程序里有lock tables这样的语句，需要排查：
	1. 你的系统现在还在用MyISAM这类不支持事务的引擎；
	2. 引擎升级但是代码没升级；

MDL会直到事务提交才释放，在做表结构变更的时候，一定要防止锁住线上查询和更新。
