可重复度隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。

 

Begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。

 

MySQL中，有两个“视图”的概念：

- 一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view …，而它的查询方法与表一样。
- 另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Commintted，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。

 

快照

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。这个快照是基于整库的。

 

快照的实现

InnoDB里每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请，是按申请顺序严格递增。

而每行数据也都是有多个版本。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。

一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。如果上一个版本也不可见，就继续往前找；如果是这个事务自己更新的数据，也认。

 

InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”（指启动了但未提交）的所有事务ID。

数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。

这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。

数据版本的可见性规则，基于数据的row trx_id和这个一致性视图的对比结果得到的。

 

InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。

 

可重复读的核心就是一致性读；事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

 

读提交的逻辑和可重复读的逻辑类似，它们的区别是：

- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

 

幻读：指一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行；

 

 

 

===============old=================

事务：就是要保证一组数据库操作，要么全部成功，要么全部失败。事务支持是在引擎层实现。

 

数据库事务（ACID四大特性）

1. 原子性（atomicity），一个事务内所有操作共同组成一个原子包，要么全部成功，要么全部失败；
2. 一致性（consistency），一致性基于原子性，原子性只保证了一个事务内的所有操作同一性，没有保证同一事务中所有操作同一时刻一起生、一起死；计算指令有先后顺序，决定了一个事务的提交，会经历一个时间过程，数据库事务的一致性规定了事务提交前后，永远只可能存在事务提交前的状态和事务提交以后的状态，从一个一致性的状态到另一个一致性状态，不存在中间的过程态；
3. 隔离性（isolation），隔离性基于原子性和一致性，多个事务以原子包的形式并发的执行，但是每个事务互不干扰；由于多个事务可能操作同一资源，不同的事务为了保证隔离性，会有很多锁方案；
4. 持久性（durability），当一个事务提交以后，数据库的状态永远的发生了改变；

 

三个概念：

1. 幻读：幻读侧重的方面是某一次的select操作得到的结果所表征的数据状态无法支撑后续的业务操作。select某记录是否存在，不存在，准备插入此记录，但是执行insert时发现此记录已存在，无法插入，此时就产生了幻读。mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。insert属于隐士的读，用于检查主键冲突，不可重复读侧重表达的是读-读，幻读侧重读-写；
2. 脏读：一个事务读到另一个事务没有提交的数据；
3. 不可重复读：事务A执行两次select操作得到不同的数据集，即select1得到10条记录，select2得到11条记录，在R-U、R_C级别下出现；A事务在执行过程中，B事务对数据进行了修改或删除，导致A两次读取的数据不一致；重点在于update和delete（锁行即可解决），

 

当数据库有多个事务同时执行时，可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了事务隔离级别；

 

事务隔离界别越高，效率越低

 

事务的四级隔离级别：

| 级别     | symbol           | 描述                                             | 值   | 存在问题                                                     |
| -------- | ---------------- | ------------------------------------------------ | ---- | ------------------------------------------------------------ |
| 读未提交 | READ-UNCOMMITTED | 一个事务还没提交，它做的变更就能被别的事务看到； | 0    | 存在脏读、不可重复读、幻读的问题                             |
| 读已提交 | READ-COMMITTED   | 一个事务提交以后，他做的变更才会被其他事务看到； | 1    | 解决脏读的问题，存在不可重复读、幻读的问题                   |
| 可重复读 | REPEATABLE-READ  |                                                  | 2    | MySQL默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用MMVC机制 实现可重复读 |
| 序列化   | SERIALIZABLE     |                                                  | 3    | 解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低 |

 

避免长事务：