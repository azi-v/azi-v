多线程、消息传递

Go语言基于消息并发模型，基于CSP模型；
goroutine之间共享内存；

goroutine和系统线程
Goroutine是一种轻量级的线程，goroutine和系统线程不等价；两者之间的区别实际上只是一个量的区别；
每个系统线程会有固定大小的栈(默认是2MB)，用来保存函数递归调用时参数和局部变量；固定大小的栈会导致对于只需要很小的栈空间的线程内存空间的巨大浪费，对于少数需要巨大栈空间的线程来说面临栈溢出的风险。
Goroutine以很小的栈启动(2kb或4kb)，当遇到深度递归导致当前栈空间不足时，goroutine会根据需要动态地伸缩栈的大小（主流实现中栈的最大值可达1GB）。启动代价小，所以可以轻易启动成千上万个goroutine。

Go运行时包含了自己的调度器，调度器可以在n个操作系统线程上多工调度m个goroutine。go调度器的工作和内核的调度是相识的，但go调度器只关注单独的Go程序中的goroutine。
Goroutine采用半抢占式（？？？）的协程调度，只在当前goroutine发生阻塞时才会导致调度；同时发生在用户态，调度器会根据具体函数只保存必要的寄存器，切换的代价比系统线程低很多。
runtime.GOMAXPROCS变量，用于控制当前正常非阻塞goroutine的系统线程数目。

原子操作
原子操作是并发编程中“最小的且不可并行化”的操作。
原子操作对于多线程并发编程模型来说，不会发生有别于单线程的意外情况，共享资源的完整性得到保证。
原子操作一般通过“互斥”访问来保证，通常由特殊的CPU指令提供保护。

用互斥锁保护一个数值型的共享资源，效率低下。
sync/atomic包对原子操作提供了丰富的支持。

顺序一致性模型
同一个goroutine线程内部，顺序一致性内存模型是得到保证的；在不同goroutine之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考。
如果两个事件不可排序，那么这两个事件是并发的。
为了最大化并行，Go语言的编译器和处理器在不影响上述规定的前提下，会对执行语句重新排序。
如果两个并发程序无法确定事件的顺序关系，那么程序的运行结果往往会得到不确定的结果。
Go语言规范（？？？），main函数退出时程序结束，不会等待任何后台线程；goroutine的执行和main函数的返回事件是并发的；

通过同步原语给两个事件明确排序；goroutine 中向chan中发送数据，main中接收chan；不带缓冲的chan会阻塞main；

基于channel的通讯
在无缓存的channel上每一次发送操作都有与其对应的接收操作相配对，发送和接收操作通常发生在不同的goroutine上，在同一个goroutine上执行2个操作很容易导致死锁。
无缓存的channel上的发送操作总在对应的接收操作完成前发生；

在关闭channel后继续从中接收数据，接收者会收到该channel返回的零值；
根据控制channel的缓存大小来控制并发执行的goroutine的最大数目；
select{}是一个空的管道选择语句，会导致goroutine阻塞；
调用os.Exit(0)可以让程序正常退出；
