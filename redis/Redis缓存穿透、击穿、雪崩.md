
	1. 缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源；比如一个不存在的用户id，无论缓存数据库都不存在；
	2. 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量的并发请求过来，发现缓存过期都会从DB加载数据并回设到缓存，大并发的数据可能会瞬间把后端DB压垮；
	3. 缓存雪崩：当缓存服务器重启或大量缓存集在某个时间失效，失效期间，会给DB带来很大压力；
Redis缓存穿透解决方案：
	1. 布隆过滤器，将可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免对底层存储系统的查询压力；
	2. 查询返回的数据为空，空结果进行缓存，过期时间很短，不超过五分钟；
Redis缓存击穿解决方案：
	1. 互斥锁
Redis缓存雪崩解决方案：
	1. 加锁或队列的方式，保证不会有大量的线程对数据库一次性进行读写；
	2. 在原有失效时间上增加随机值，缓存过期时间的重复率会降低；
	3. 缓存标记，记录缓存数据是否过期，如果过期触发通知另外的线程在后台更新实际的key缓存；缓存数据的过期时间比缓存标记过期时间延长一倍；

Redis分布式
项目中使用redis的原因：性能与并发角度；性能：执行耗时久，结果不频繁变动，运行结果放入缓存；并发：在大并发的情况下，所有请求直接访问数据库，数据库会出现连接异常；
Redis分布式部署：
分布式锁实现方式：
	1. 基于数据库实现
	2. 基于zookeeper的临时序列化节点实现 
	3. redis实现：通过redis的setnx实现，只有第一次执行的才会成功并返回1，其它情况返回0；释放锁其实只需要把锁的key删除即可，使用del xxx指令。不过，如果在我们执行del之前，服务突然宕机，那么锁就永远无法删除了。所以我们可以通过setex 命令设置过期时间即可。


Redis使用的四个问题：
	1. Redis缓存和数据库双写一致性问题；
	2. Redis缓存的并发竞争问题；
	3. 缓存雪崩问题；
	4. 缓存击穿问题；

单线程Redis为什么这么快：
	1. Redis是单线程工作模型，单线程操作避免频繁的上下文切换；
	2. 纯内存操作；
	3. 采用非阻塞I/O多路复用机制（redis提供了select、epoll、evport、kqueue多路复用函数库，redis中所有的顶级key都可以设置过期时间）；

Redis数据类型：
	1. String：
	2. Hash:
	3. List :简单的消息队列功能，lrange，基于redis的分页功能；
	4. Set：交并差集；共同喜好、全部喜好等；
	5. SortedSet：按score排序；排行榜top N、延时任务、范围查找；

Redis过期策略：
定期删除+惰性删除
定期删除：定期随机抽取key进行检查；
惰性删除：获取某个key时，会检查key是否设置了过期时间，是否过期了；

Redis内存淘汰策略：
maxmemory-policy volatile-lru：
	1. noeviction：内存不足，新写入数据直接报错；
	2. allkeys-lru：异常最近最少使用的key；
	3. allkeys-random：随机删除某个key；
	4. volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的key；
	5. volatile-random：在设置了过期时间的键空间中，随机移除某个key；
	6. volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的key有限移除；

Redis与数据库双写一致性问题：
一致性问题可分为：最终一致性和强一致性；
如果对数据有强一致性要求，不能放缓存；只能保证最终一致性，从根本上说只能降低不一致性发生的概率，无法完全避免；
正确的更新策略：先更新数据库，再删缓存，删除缓存失败，提供补偿措施，利用消息队列；

Redis并发竞争key问题：
问题描述：同时多个子系统去set一个key；redis集群环境，数据做了分片操作；
解决方案：分布式锁；

Redis集群存储原理：
Redis对每一个可以进行hash操作，生成一个[0-16384]的hash值，crc算法后对16384取余，然后将[0-16384]的区间进行拆分，放在不同的redis中。

分布式高可用集群概念：
通过分布式架构解决性能（高并发）问题；通过集群架构解决故障服务（高可用）问题；
分布式：一个业务分拆为多个子业务，部署在不同的服务器上；
	1. 分布式计算：将大量的任务分配到多个计算单元上以提高计算性能；
	2. 分布式存储：将大量数据分配到多个单元上以提高总存储量；MySQL的 fbric、mycat；
分布式架构理论上都支持无线水平拓展；
集群：同一个业务，部署在多个服务器上；在多个服务器上部署同一个业务，起到两个作用：
	1. 分散每台服务器的压力；
	2. 任意一台或几台服务器宕机不会影响到整个系统；
用到分布式架构的基本上都会用到集群，用到集群架构的系统不一定会用到分布式；
Redis高可用方案：Redis Sentinel（哨兵模式）
主从模式，master-slaver，一主多从；监控主从服务器运行情况；提醒；自动故障迁移；
主观下线与客观下线；客观下线只适用于主服务器；
Redis分布式高可用方案：Redis Cluster
主要用途：数据分片，完整的sharding、replication；每个分片只保存一部分数据；hash槽（slot）概念，redis客户端任意访问一个redis实例，如果数据不在该实例中，通过重定向引导客户端访问所需要的redis实例

Redis的持久化：
	1. AOF，持久化记录服务期执行的所有写操作命令，并在服务器启动时，重新执行这些命令来还原数据集；
	2. RDB，在指定时间间隔内生成数据集的时间点快照；
AOF 文件的体积通常要大于 RDB 文件的体积，同步慢，会因为部分命令的bug导致整个aof命令重新载入；
RDB每次保存时，会fork出一个子进程，数据集庞大时，fork()会非常耗时；



HTTP接口设计时需要注意什么？
URI（同一资源标记符）
